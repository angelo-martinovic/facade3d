function Project2DOntoPointCloud(obj,labelingSource)
   
    if nargin~=2
        error('Usage: Project2DOntoPointCloud(obj,labelingSource)');
    end
    
    subset = 'eval';
    nClasses = obj.nClasses;
   
    % Read the 3D points
    points = obj.GetAllPoints;

    % Read camera information from CMVS
    cameras = ImportCameras([obj.dirName 'cameras.txt']);

    % Subset of images used to project the labeling
    file_str_idx = obj.LoadFilenames(subset);
    nImages = length(file_str_idx);
    
    % Mapping between cmvs images and labeled image
    histLabelsPerPoint_L1 = zeros(length(points),nClasses);
    histLabelsPerPoint_L2 = zeros(length(points),nClasses);
    
    probsPerPoint = zeros(length(points),nImages,nClasses);
        
    % For each image
    tic;
    fprintf('Projecting labeling onto the point cloud / mesh\n');
    cnt = 0;
    for i=1:nImages
        basename = file_str_idx{i};
        bb=cellfun(@(x)strcmp(x.originalImageFilename(1:end-4),basename),cameras,'UniformOutput',false);
        camIdx = find(cell2mat(bb));
        
        if mod(i,10)==0
            fprintf('\n%d   ',i);
        end
        if isempty(camIdx)
            error('No camera found!');
        end
        
        height = cameras{camIdx}.principalPoint(2)*2;
        width = cameras{camIdx}.principalPoint(1)*2;
        
        % Generated by 2D labeling
        labelingFilename = [obj.dirName 'work/classifier/' labelingSource '/' basename '_2Dpotentials.mat'];

        if exist(labelingFilename,'file')
            cnt = cnt+1;

            load(labelingFilename);
            
            nDet = length(detectionData);
            
            if ~exist('detMap','var')
                detMap = cell(1,nDet);
                detName = cell(1,nDet);
                probsPerPointDet = cell(1,nDet);
            end
            
            for j=1:nDet
                detMap{j} = detectionData(j).detectionMap;
                detName{j} = detectionData(j).name;
                probsPerPointDet{j} = zeros(length(points),nImages,nClasses);
            end
          
            if height==size(layer1_labeling,2) && width==size(layer1_labeling,1)
                layer1_labeling = imrotate(layer1_labeling,90);
                layer2_labeling = imrotate(layer2_labeling,90);
                segPotentials = imrotate(segPotentials,90);
      
                for j=1:nDet
                    detMap{j} = imrotate(detMap{j},90);
                end

            else
                error('Camera-labeling size mismatch!');
            end
            
            % Backproject the labeling onto the point cloud
            newLabels_i = BackProjectLabeling(points,layer1_labeling,cameras{camIdx});
            [indices,~,labels] = find(newLabels_i);
            realIndices = sub2ind(size(histLabelsPerPoint_L1),indices,labels);
            histLabelsPerPoint_L1(realIndices) = histLabelsPerPoint_L1(realIndices)+1;
            
            newLabels_i = BackProjectLabeling(points,layer2_labeling,cameras{camIdx});
            [indices,~,labels] = find(newLabels_i);
            realIndices = sub2ind(size(histLabelsPerPoint_L2),indices,labels);
            histLabelsPerPoint_L2(realIndices) = histLabelsPerPoint_L2(realIndices)+1;
            
            % Backproject the probabilities
            for c=1:nClasses
                probsPerPoint(:,i,c) = BackProjectLabeling(points,segPotentials(:,:,c),cameras{camIdx});
            end
            for j=1:nDet
                for c=1:nClasses
                    probsPerPointDet{j}(:,i,c) = BackProjectLabeling(points,detMap{j}(:,:,c),cameras{camIdx});
                end
            end
            
            fprintf('o');
        else
            fprintf('x');
            continue;
        end

    end
    
    unary = [points squeeze(sum(probsPerPoint,2)./sum(probsPerPoint~=0,2))]';
    unary(isnan(unary)) = 1/nClasses;
    
    unaryDet = cell(1,nDet);
    for j=1:nDet
        un = [points squeeze(sum(probsPerPointDet{j},2)./sum(probsPerPointDet{j}~=0,2))]';
        un(isnan(un)) = 1/nClasses;
        
        unaryDet{j}.unary = un;
        unaryDet{j}.name = detName{j};
    end
    
    fprintf('Labeled the %s point cloud with %d labeled images.\n',subset,cnt);

    % Each camera projects only on a subset of the point cloud
    % For every point, find the most common label excluding label 0
    fprintf('Majority voting...\n');
    [~,labeling_L1] = max(histLabelsPerPoint_L1,[],2);
    [~,labeling_L2] = max(histLabelsPerPoint_L2,[],2);
    
    labeling_L1 = labeling_L1 + 1;
    labeling_L2 = labeling_L2 + 1;
    
    labeling_L1(sum(histLabelsPerPoint_L1,2)==0) = 1;
    labeling_L2(sum(histLabelsPerPoint_L2,2)==0) = 1;

    projectionTime = toc;
    fprintf('Time elapsed: %d seconds.\n',projectionTime);
        
    % Mapping colors
    newColors_L1 =  obj.cm(labeling_L1,:);
    newColors_L2 =  obj.cm(labeling_L2,:);
    
    if ~exist([obj.dirName 'work/pcl/'],'dir')
        mkdir([obj.dirName 'work/pcl/']);
    end
    if ~exist([obj.dirName 'work/pcl/models/'],'dir')
        mkdir([obj.dirName 'work/pcl/models/']);
    end

    if ~exist([obj.dirName 'work/pcl/probs/'],'dir')
        mkdir([obj.dirName 'work/pcl/probs/']);
    end
    
    ExportMesh([obj.dirName 'work/pcl/models/' obj.modelName  '_L1_majorityVote.ply'],points,[],newColors_L1,[],[]);
    ExportMesh([obj.dirName 'work/pcl/models/' obj.modelName  '_L2_majorityVote.ply'],points,[],newColors_L2,[],[]);

    save([obj.dirName 'work/pcl/probs/' obj.modelName  '_2Dunary.mat'],'unary','unaryDet');

end